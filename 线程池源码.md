# ThreadPoolExecutor源码解析
## 线程池状态
* RUNNING：接受新任务并处理排队任务
* SHUTDOWN：不接受新任务，但是处理排队任务
* STOP：不接受新任务，不处理排队的任务，并中断正在进行的任务
* TIDYING：过渡状态，所有任务都终止，并且队列为0，当前线程池已经没有有效的线程，并且将要调用terminated方法
* TERMINATED：终止状态，terminated方法调用结束

线程池内部使用一个整型变量来保持线程的状态以及当前线程数的数量的。即：
`private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));`
### java中整型一共32位，其中后29位保存线程池中运行线程数
```java
//29
private static final int COUNT_BITS = Integer.SIZE - 3;
//00011111111111111111111111111111
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
```
### 前3位来保持线程池状态，分别为111，000，001，010，011:
```java
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```
这几个数值有顺序，运行大小比较，runState单调增，状态转化为：
* RUNNING -> SHUTDOWN：显示调用shutdown()，或者GC时候finalize()也会调用shutdown()
* (RUNNING or SHUTDOWN) -> STOP：调用shutdownNow()
* SHUTDOWN -> TIDYING：当队列以及线程池都为空时
* STOP -> TIDYING：当线程池为空
* TIDYING -> TERMINATED：terminated方法调用完成之后
### 处理ctl
1. 得到当前的线程池状态：
`private static int runStateOf(int c)     { return c & ~CAPACITY; }` 

`~CAPACITY`为11100000000000000000000000000000，与操作相当于取前3位的值

2. 得到线程数，同上：
`private static int workerCountOf(int c)  { return c & CAPACITY; }`

3.更新线程数量以及状态，或操作：
`private static int ctlOf(int rs, int wc) { return rs | wc; }`
# 任务执行
可以使用execute()、 submit()提交任务，区别在于submit()使用FutureTask包装了Runnable。
>此时futureTask执行到run方法时，遇到异常会在异常处理时候调用FutureTask#setException，并不会将异常抛出，只有等到使用FutureTask#get，才会抛出异常

最后统一都会调到ThreadPoolExecutor#execute
## execute
execute()主要分为3部分：
1. 如果当前执行的线程数比核心线程数要小，则调用addWorker，创建一个Worker执行任务。除了前几个任务是通过步骤1处理的，其他都是步骤2、3。
2. 如果当前线程大于等于核心线程，且线程池是running状态，将任务加入阻塞队列。即使有线程是空闲的，也会先加入到阻塞队列，让线程从队列中获取。当线程由因异常而退出或者核心线程数为0时，确保当前有线程执行任务，而不是任务被加到阻塞队列一直得不到执行。
3. 加入阻塞队列失败，会尝试调用addWorker再起一个线程去执行该任务
```java
int c = ctl.get();
//1
if (workerCountOf(c) < corePoolSize) {
	if (addWorker(command, true))
    	return;
    c = ctl.get();
}
//2
if (isRunning(c) && workQueue.offer(command)) {
	int recheck = ctl.get();
    if (! isRunning(recheck) && remove(command))//需要再次检查线程池状态，当状态不满足时，从队列中移除刚加入的任务
    	reject(command);
    else if (workerCountOf(recheck) == 0)//查看当前worker数，确保当前有线程执行任务
    	addWorker(null, false);
    }
//3
else if (!addWorker(command, false))
	reject(command);
```
## addWork
往线程池中添加线程的方法。线程池中使用内部类Work来封装线程。
1. 检查线程池状态
2. 检查当前工作线程数，满足条件使用CAS将当前线程数+1
3. 基于firstTask构造出Worker对象，加入到线程池set中，并启动该Worker

在Worker启动之前，调用了线程池的**mianLock**。使用mainLock主要原因有：
* 存放所有worker的set是HashSet，线程不安全。不使用线程安全的集合原因是：
> Among the reasons is that this serializes interruptIdleWorkers, which avoids unnecessary interrupt storms, especially during shutdown

多个线程调用时候可以保证串行化处理，尤其是调用interruptIdleWorkers()。避免中断风暴（过密集的中断请求，影响性能
* 方便largestPoolSize之类的统计，不使用volatile，是因为addworker还未执行到+1时候，就去统计

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        //即：rs > SHUTDOWN || (rs = SHUTDOWN && (firstTask !=null || workQueue.isEmpty()))
		//检查线程池状态，1.当线程池状态是stop、tidying、terminated; 2.线程池是shutdown,阻塞队列为空或者加入新任务,满足任一返回false
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            //根据入参来判断是否当前线程数大于等于核心线程数或者最大线程数
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //CAS将当前worker数+1，成功跳出循环
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();
            //检查线程池状态是否发生变化，重新开始循环，否则只进行CAS循环
            if (runStateOf(c) != rs)
                continue retry;
        }
    }
	//此时work数已经+1成功
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
        	//因为workers是hashset,线程不安全，需要持有mainLock才能被访问
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // 判断线程是否已经started，因为此时还未start()，肯定要抛出异常
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    //历史最大线程数，而maximumPoolSize是静态的最大线程数
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;//标记worker添加成功
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();//启动线程，调用Worker的run()
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
        	//启动失败执行，1.从haseSet中移除worker 2.worker数-1 3.尝试终止线程池(后面showdown分析)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```
## Worker
此类主要是对线程的包装。继承了AQS，主要是为了维护**运行中线程的中断状态**。为了中断那些等待任务的线程而不是运行中的线程。继承AQS，为了实现不可重入，主要是为了不想打断正在执行的线程，比如setCorePoolSize()
```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{

    final Thread thread;
    Runnable firstTask;

    Worker(Runnable firstTask) {
    //为了在线程真正开始运行任务前，抑制中断，设置为-1，这样执行tryAcquire()也就获取不到锁。
    //在runworker()时候，一开始就会调用unlock()方法，将state设置为0
        setState(-1); 
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    public void run() {
        runWorker(this);
    }
    //0代表没被锁，1代表被锁
    protected boolean isHeldExclusively() {
    	return getState() != 0;
    }
    //在runWorker()方法中执行
    public void lock()        { acquire(1); }
    //在interruptIdleWorkers()方法中执行，中断线程前判断线程是否正在执行
    public boolean tryLock()  { return tryAcquire(1); }    
}
```
## runWorker
```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}   
```